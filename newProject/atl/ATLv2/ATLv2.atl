query Script = MM!Model->allInstances()->asSequence().first().GenerateJavaCode().writeTo('/ATLv2/JavaTargetModels/main.java');

							
helper context MM!Model def : GenerateJavaCode() : String = 
	
	  let  stateMachines : MM!StateMachine = MM!StateMachine.allInstances() in
	     '/* \n'+
		 ' * Automatically generated Java code with ATL \n'+
		 ' */ \n'+
		 stateMachines->iterate(it; Class_Code: String = ''|Class_Code 
	        + it.getGeneralRegion(it))
          ;

helper context MM!StateMachine def : getGeneralRegion(x:MM!StateMachine) : String =
	let regions : MM!Region = x.region->select(a|a.oclIsTypeOf(MM!Region)) in 
		 regions->iterate(it; result: String = ''|result 
	        + it.generateCode(it))
          ;

helper context MM!Region def : generateCode(x:MM!Region) : String = 
	let stateRegion : MM!State = x.subvertex->select(a|a.oclIsTypeOf(MM!State)) in
	let transitions : MM!Transition = x.transition->select(a|a.oclIsTypeOf(MM!Transition)) in 
	let initials : MM!Pseudostate = x.subvertex->select(a|a.oclIsTypeOf(MM!Pseudostate)) in
	let finals : MM!FinalState = x.subvertex->select(a|a.oclIsTypeOf(MM!FinalState)) in
	
		' ' 
		+ x.generateFirstTransition(transitions)
		+ x.generateClasses(stateRegion->first())
		+ x.generateGuards()
		+ x.generateMetadata()
		+ x.generateBeginningOfApplication()
		+'// Main states creation\n'
		+ x.generateInitialState(initials)
		+ x.generateFinalState(finals)
		+ x.generateState(stateRegion)
		+ x.generateAllStates(stateRegion->first())
		;
	
helper context MM!Region def :  generateFirstTransition(x:MM!Transition) : String = 
	x->iterate(it; result: String = ''|result
		+ if(it.name.toString()<>'OclUndefined') then 
'// Event corresponding to "' + it.name +
	'\n public class '+it.name+'Event extends Event { \n public '+it.name+'Event() { \n super("'+it.name+'");
	  }
	}'
		else '' 
		endif
	);

helper context MM!Region def :  generateClasses(x:MM!State) : String = 
	let region : MM!Region = x.region->select(a|a.oclIsTypeOf(MM!Region)) in 
		region->iterate(it; result: String = ''|result
			+x.generateCodeFromRegion(it)
	);

helper context MM!State def :  generateCodeFromRegion(x:MM!Region) : String = 
	let transitions : MM!Transition = x.transition->select(a|a.oclIsTypeOf(MM!Transition)) in
	let pseudoStates : MM!Pseudostate = x.subvertex->select(a|a.oclIsTypeOf(MM!Pseudostate)) in
			x.generateTransitions(transitions,pseudoStates)
			+x.generateActionClasses()
			
	;


helper context MM!Region def : generateTransitions(x:MM!Transition, y:MM!Pseudostate) : String = 
		x->iterate(it; result: String = ''|result
		+if(it.name.toString()<>'OclUndefined') then 
			if(it.source.oclIsTypeOf(MM!Pseudostate)=false) then
				'// Event corresponding to "' + it.name +
					'\n public class '+it.name+'Event extends Event { \n public '+it.name+'Event() { \n super("'+it.name+'");
					  }
					}'
			else '' 
			endif
		else ''
		endif
		);

helper context MM!Region def : generateActionClasses() : String = 
		'
// Action creation

// Action corresponding to "setSpeed(...)"
public class SetSpeed extends Action {
  private int value;

  public void SetSpeed(int value) {
    this.value = value;
  }

  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}

// Acction corresponding to "increaseSpeed()"
public class IncreaseSpeed extends Action {
  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}

// Acction corresponding to "decreaseSpeed()"
public class DecreaseSpeed extends Action {
  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}

// Acction corresponding to "rotateleft()"
public class Rotateleft extends Action {
  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}

// Acction corresponding to "rotateright()"
public class Rotateright extends Action {
  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}

// Acction corresponding to "shutdown()"
public class Shutdown extends Action {
  public void execute(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}
		';
	
	
helper context MM!Region def : generateGuards() : String = 
'// Guard creation

// Guard corresponding to "SpeedEquals(...)"
public class SpeedEquals extends Guard {
  private int value;

  public SpeedEquals(int value) {
   this.value = value;
  }

  public boolean check(Metadata data, Parameter parameter) {
    //TODO: complete this function
  }
}';

helper context MM!Region def : generateMetadata() : String = 
'// Metadata creation
public class MyMetadata extends Metadata {
  //TODO: add variables used in functions
}'
;


helper context MM!Region def : generateBeginningOfApplication() : String = 
'\n\n// Main Application
public class Application{

  public static void main(String[] args){

    // Statechart initialisation
    Statechart statechart = new Statechart();'
;

helper context MM!Region def :  generateInitialState(x:MM!Pseudostate) : String = 
	x->iterate(it; result: String = ''|result
		+'	PseudoState '+it.name.toLowerCase()+'State = new PseudoState("'+it.name+'", statechart, PseudoState.pseudostate_start);\n'
	);

helper context MM!Region def :  generateFinalState(x:MM!FinalState) : String = 
	x->iterate(it; result: String = ''|result
		+'	FinalState '+it.name.toLowerCase()+'State = new FinalState("'+it.name+'", statechart);\n'
	);

helper context MM!Region def :  generateState(x:MM!State) : String = 
	x->iterate(it; result: String = ''|result
		+'	State '+it.name.toLowerCase()+'State = new State("'+it.name+'", statechart);\n'
	);

helper context MM!Region def :  generateAllStates(x:MM!State) : String = 
	let region : MM!Region = x.region->select(a|a.oclIsTypeOf(MM!Region)) in 
		region->iterate(it; result: String = ''|result
			+x.generateStatesCode(it)
	);


helper context MM!State def :  generateStatesCode(x:MM!Region) : String = 
	let states : MM!State = x.subvertex->select(a|a.oclIsTypeOf(MM!State)) in
	let pseudoStates : MM!Pseudostate = x.subvertex->select(a|a.oclIsTypeOf(MM!Pseudostate)) in
		'\n    // Initial states creation		\n'
		+ x.generateNormalStates(states)
		+ x.generatePseudoStates(pseudoStates)	
	;


helper context MM!Region def : generateNormalStates(x:MM!State) : String = 
		x->iterate(it; result: String = ''|result
		+'    State '+it.name.toLowerCase()+'State = new State("'+it.name+'", initialState);\n'
		);


helper context MM!Region def : generatePseudoStates(x:MM!State) : String = 
		x->iterate(it; result: String = ''|result
		+'    PseudoState '+it.name.toLowerCase()+'PseudoState = new State("'+it.name+'", initialState);\n'
		);



		
	
	

helper context MM!Region def : generateClasses2(x:MM!State) :  String = 
	x->iterate(it; result:String =''| result
		+ 
'// Specific class and methods description for the node <' + it.name+'>
	class ' + it.name + ' extends Node {
	
	  @Override
	  onEventStart(){
	    //TODO : Complete with the code to execute when an event is call on this node
	  }

	  @Override
	  onEventDestination(){
	    //TODO : Complete with the code to execute when an event lead to this node
	  }
	
	  @Override
	  onEntering(){
	    //TODO : Complete with the code to execute when you enter in this node
	  }
	
	  @Override
	  onLeaving(){
	    //TODO : Complete with the code to execute when you leave this node
	  }
	
	}\n\n'		
		
		)
		;

helper context MM!Region def : generateApplicationClass(x:MM!State) :  String =
	'class Application{

  public static void main(String[] args){
    // Graph initialization
    Graph graph = new Graph();

    // Nodes initionazation and adding to the graph\n'
	+ x->iterate(it; result:String =''| result
		+ it.name
		+ ' '
		+ it.name.toLowerCase()
		+ ' = new '
		+ it.name
		+'();\n'
		+ 'graph.addNode('
		+ it.name.toLowerCase()
		+ ');\n\n'
	);


helper context MM!Region def : generateInitial(x:MM!Pseudostate, trans:MM!Transition, states:MM!State) :  String =
	'// Set starting nodes of the graph\n'
	+
	x->iterate(it; result: String = ''|result
		+trans->iterate(its; results: String = ''|results
			+''
			+ if(its.source=it) then 
				states->select(a|a=its.target)->iterate(itp; resultp: String = ''|resultp
					+'graph.setStartingNode('
					+ itp.name
					+ ');\n\n'
					)
			else '' 
			endif
		)
	);

helper context MM!Region def : generateFinal(x:MM!FinalState, trans:MM!Transition, states:MM!State) :  String =
	'// Set ending nodes of the graph\n'
	+
	x->iterate(it; result: String = ''|result
		+trans->iterate(its; results: String = ''|results
			+''
			+ if(its.target=it) then 
				states->select(a|a=its.source)->iterate(itp; resultp: String = ''|resultp
					+'graph.setEndingNode('
					+ itp.name
					+ ');\n\n'
					)
			else '' 
			endif
		)
	);
		



helper context MM!Region def :  generateTransitions2(x:MM!Transition) : String = 
	'//Set the transitions\n'
	+
	x->iterate(it; result: String = ''|result
		+ '' + 
		if(it.toString()<>'OclUndefined') then 
			if(it.source.oclIsTypeOf(MM!Pseudostate)=false) then
				if(it.target.oclIsTypeOf(MM!FinalState)=false) then
    				'graph.addSwitch('
    				+it.source.name
					+', '
					+it.target.name
					+', "'
					+it.name
					+'");\n'
				else '' 
				endif
			else '' 
			endif
		else '' 
		endif
	);
			
